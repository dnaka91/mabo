use std::fmt::{self, Display, Write};

use stef_parser::{
    Comment, Const, DataType, Definition, Enum, ExternalType, Fields, Generics, Literal, Name,
    Schema, Struct, Type, TypeAlias, Variant,
};

use crate::{decode, encode, size, Opts, Output};

/// Take a single schema and convert it into Go source code (which can result in multiple files).
#[must_use]
pub fn render_schema<'a>(
    opts: &'a Opts<'_>,
    Schema { definitions, .. }: &'a Schema<'_>,
) -> Output<'a> {
    let mut content = format!(
        "{}{}{}",
        RenderHeader,
        RenderImports,
        RenderPackage(opts.package, None)
    );

    let modules = definitions
        .iter()
        .filter_map(|def| render_definition(&mut content, def))
        .collect();

    Output {
        name: opts.package,
        content,
        modules,
    }
}

fn render_definition<'a>(buf: &mut String, definition: &'a Definition<'_>) -> Option<Output<'a>> {
    match definition {
        Definition::Module(m) => {
            let mut content = format!(
                "{}{}",
                RenderHeader,
                RenderPackage(m.name.get(), Some(&m.comment))
            );

            let modules = m
                .definitions
                .iter()
                .filter_map(|def| render_definition(&mut content, def))
                .collect();

            return Some(Output {
                name: m.name.get(),
                content,
                modules,
            });
        }
        Definition::Struct(s) => {
            writeln!(buf, "{}", RenderStruct(s)).unwrap();
            writeln!(
                buf,
                "{}",
                RenderNewFunc {
                    name: heck::AsUpperCamelCase(&s.name),
                    generics: &s.generics,
                    fields: &s.fields,
                    filter_generics: false,
                }
            )
            .unwrap();
            writeln!(
                buf,
                "\n{}\n{}\n{}",
                encode::RenderStruct(s),
                decode::RenderStruct(s),
                size::RenderStruct(s),
            )
            .unwrap();
        }
        Definition::Enum(e) => writeln!(buf, "{}", RenderEnum(e)).unwrap(),
        Definition::TypeAlias(a) => write!(buf, "{}", RenderAlias(a)).unwrap(),
        Definition::Const(c) => write!(buf, "{}", RenderConst(c)).unwrap(),
        Definition::Import(_) => {}
    }

    None
}

struct RenderHeader;

impl Display for RenderHeader {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            "// Code generated by {} (v{}). DO NOT EDIT.\n",
            env!("CARGO_PKG_NAME"),
            env!("CARGO_PKG_VERSION"),
        )
    }
}

struct RenderPackage<'a>(&'a str, Option<&'a Comment<'a>>);

impl Display for RenderPackage<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some(comment) = self.1 {
            write!(f, "{}", RenderComment { indent: 0, comment })?;
        }

        writeln!(f, "package {}\n", heck::AsSnakeCase(self.0))
    }
}

struct RenderImports;

impl Display for RenderImports {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "import (")?;
        writeln!(f, "\t\"github.com/dnaka91/stef-go\"")?;
        writeln!(f, "\t\"github.com/dnaka91/stef-go/buf\"")?;
        writeln!(f, ")\n")
    }
}

struct RenderStruct<'a>(&'a Struct<'a>);

impl Display for RenderStruct<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            "{}type {}{} {}",
            RenderComment {
                indent: 0,
                comment: &self.0.comment
            },
            heck::AsUpperCamelCase(&self.0.name),
            RenderGenerics {
                generics: &self.0.generics,
                fields_filter: None
            },
            RenderFields(&self.0.fields)
        )
    }
}

struct RenderNewFunc<'a, T> {
    name: T,
    generics: &'a Generics<'a>,
    fields: &'a Fields<'a>,
    filter_generics: bool,
}

impl<T> Display for RenderNewFunc<'_, T>
where
    T: Display,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            "func New{}{}({}) {0}{} {{",
            self.name,
            RenderGenerics {
                generics: self.generics,
                fields_filter: self.filter_generics.then_some(self.fields)
            },
            RenderParameters(self.fields),
            RenderGenericNames {
                generics: self.generics,
                fields_filter: self.filter_generics.then_some(self.fields)
            },
        )?;
        writeln!(
            f,
            "\treturn {}{}{}",
            self.name,
            RenderGenericNames {
                generics: self.generics,
                fields_filter: self.filter_generics.then_some(self.fields)
            },
            RenderConstructor(self.fields),
        )?;
        write!(f, "}}")
    }
}

struct RenderGenerics<'a> {
    generics: &'a Generics<'a>,
    fields_filter: Option<&'a Fields<'a>>,
}

impl Display for RenderGenerics<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.fields_filter {
            Some(fields) => {
                if !self.generics.0.iter().any(|gen| uses_generic(gen, fields)) {
                    return Ok(());
                }
            }
            None => {
                if self.generics.0.is_empty() {
                    return Ok(());
                }
            }
        }

        f.write_char('[')?;
        for (i, value) in self
            .generics
            .0
            .iter()
            .filter(|gen| match self.fields_filter {
                Some(fields) => uses_generic(gen, fields),
                None => true,
            })
            .enumerate()
        {
            if i > 0 {
                f.write_str(", ")?;
            }
            write!(f, "{value} any")?;
        }
        f.write_char(']')
    }
}

pub(super) struct RenderGenericNames<'a> {
    pub(super) generics: &'a Generics<'a>,
    pub(super) fields_filter: Option<&'a Fields<'a>>,
}

impl Display for RenderGenericNames<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.fields_filter {
            Some(fields) => {
                if !self.generics.0.iter().any(|gen| uses_generic(gen, fields)) {
                    return Ok(());
                }
            }
            None => {
                if self.generics.0.is_empty() {
                    return Ok(());
                }
            }
        }

        f.write_char('[')?;
        for (i, value) in self
            .generics
            .0
            .iter()
            .filter(|gen| match self.fields_filter {
                Some(fields) => uses_generic(gen, fields),
                None => true,
            })
            .enumerate()
        {
            if i > 0 {
                f.write_str(", ")?;
            }
            write!(f, "{value}")?;
        }
        f.write_char(']')
    }
}

struct RenderGenericTypes<'a>(&'a [Type<'a>]);

impl Display for RenderGenericTypes<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.0.is_empty() {
            return Ok(());
        }

        f.write_char('[')?;
        for (i, value) in self.0.iter().enumerate() {
            if i > 0 {
                f.write_str(", ")?;
            }
            write!(f, "{}", RenderType(value))?;
        }
        f.write_char(']')
    }
}

struct RenderFields<'a>(&'a Fields<'a>);

impl Display for RenderFields<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.0 {
            Fields::Named(named) => {
                if named.is_empty() {
                    write!(f, "struct{{}}")
                } else {
                    writeln!(f, "struct {{")?;

                    for field in named {
                        writeln!(
                            f,
                            "{}\t{} {}",
                            RenderComment {
                                indent: 1,
                                comment: &field.comment
                            },
                            heck::AsUpperCamelCase(&field.name),
                            RenderType(&field.ty)
                        )?;
                    }

                    write!(f, "}}")
                }
            }
            Fields::Unnamed(unnamed) => {
                if unnamed.is_empty() {
                    write!(f, "struct{{}}")
                } else {
                    writeln!(f, "struct {{")?;

                    for (i, field) in unnamed.iter().enumerate() {
                        writeln!(f, "\tF{i} {}", RenderType(&field.ty))?;
                    }

                    write!(f, "}}")
                }
            }
            Fields::Unit => write!(f, "struct{{}}"),
        }
    }
}

struct RenderParameters<'a>(&'a Fields<'a>);

impl Display for RenderParameters<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.0 {
            Fields::Named(named) => {
                if !named.is_empty() {
                    writeln!(f)?;
                }

                for field in named {
                    writeln!(
                        f,
                        "\t{} {},",
                        heck::AsLowerCamelCase(&field.name),
                        RenderType(&field.ty),
                    )?;
                }
            }
            Fields::Unnamed(unnamed) => {
                if !unnamed.is_empty() {
                    writeln!(f)?;
                }

                for (i, field) in unnamed.iter().enumerate() {
                    writeln!(f, "\tf{i} {},", RenderType(&field.ty))?;
                }
            }
            Fields::Unit => {}
        }

        Ok(())
    }
}

struct RenderConstructor<'a>(&'a Fields<'a>);

impl Display for RenderConstructor<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.0 {
            Fields::Named(named) => {
                if named.is_empty() {
                    write!(f, "{{}}")
                } else {
                    writeln!(f, "{{")?;

                    for field in named {
                        writeln!(
                            f,
                            "\t\t{}: {},",
                            heck::AsUpperCamelCase(&field.name),
                            heck::AsLowerCamelCase(&field.name)
                        )?;
                    }

                    write!(f, "\t}}")
                }
            }
            Fields::Unnamed(unnamed) => {
                if unnamed.is_empty() {
                    write!(f, "{{}}")
                } else {
                    writeln!(f, "{{")?;

                    for (i, _) in unnamed.iter().enumerate() {
                        writeln!(f, "\t\tF{i}: f{i},")?;
                    }

                    write!(f, "\t}}")
                }
            }
            Fields::Unit => write!(f, "{{}}"),
        }
    }
}

struct RenderAlias<'a>(&'a TypeAlias<'a>);

impl Display for RenderAlias<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}type {} {}",
            RenderComment {
                indent: 0,
                comment: &self.0.comment,
            },
            heck::AsUpperCamelCase(&self.0.name),
            RenderType(&self.0.target),
        )
    }
}

struct RenderComment<'a> {
    indent: usize,
    comment: &'a Comment<'a>,
}

impl Display for RenderComment<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for line in &self.comment.0 {
            writeln!(f, "{:\t<width$}// {line}", "", width = self.indent)?;
        }

        Ok(())
    }
}

pub(super) struct RenderType<'a>(pub(super) &'a Type<'a>);

impl Display for RenderType<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.0.value {
            DataType::Bool => write!(f, "bool"),
            DataType::U8 => write!(f, "uint8"),
            DataType::U16 => write!(f, "uint16"),
            DataType::U32 => write!(f, "uint32"),
            DataType::U64 => write!(f, "uint64"),
            DataType::U128 | DataType::I128 => write!(f, "*big.Int"),
            DataType::I8 => write!(f, "int8"),
            DataType::I16 => write!(f, "int16"),
            DataType::I32 => write!(f, "int32"),
            DataType::I64 => write!(f, "int64"),
            DataType::F32 => write!(f, "float32"),
            DataType::F64 => write!(f, "float64"),
            DataType::String | DataType::StringRef | DataType::BoxString => write!(f, "string"),
            DataType::Bytes | DataType::BytesRef | DataType::BoxBytes => write!(f, "[]byte"),
            DataType::Vec(ty) => write!(f, "[]{}", RenderType(ty)),
            DataType::HashMap(kv) => write!(f, "map[{}]{}", RenderType(&kv.0), RenderType(&kv.1)),
            DataType::HashSet(ty) => write!(f, "map[{}]struct{{}}", RenderType(ty)),
            DataType::Option(ty) => write!(f, "*{}", RenderType(ty)),
            DataType::NonZero(ty) => match &ty.value {
                DataType::U8 => write!(f, "stef.NonZeroU8"),
                DataType::U16 => write!(f, "stef.NonZeroU16"),
                DataType::U32 => write!(f, "stef.NonZeroU32"),
                DataType::U64 => write!(f, "stef.NonZeroU64"),
                DataType::U128 => write!(f, "stef.NonZeroU128"),
                DataType::I8 => write!(f, "stef.NonZeroI8"),
                DataType::I16 => write!(f, "stef.NonZeroI16"),
                DataType::I32 => write!(f, "stef.NonZeroI32"),
                DataType::I64 => write!(f, "stef.NonZeroI64"),
                DataType::I128 => write!(f, "stef.NonZeroI128"),
                DataType::F32 => write!(f, "stef.NonZeroF32"),
                DataType::F64 => write!(f, "stef.NonZeroF64"),
                DataType::String | DataType::StringRef => write!(f, "stef.NonZeroString"),
                DataType::Bytes | DataType::BytesRef => write!(f, "stef.NonZeroBytes"),
                DataType::Vec(ty) => write!(f, "stef.NonZeroVec[{}]", RenderType(ty)),
                DataType::HashMap(kv) => write!(
                    f,
                    "stef.NonZeroHashMap[{}, {}]",
                    RenderType(&kv.0),
                    RenderType(&kv.1)
                ),
                DataType::HashSet(ty) => write!(f, "stef.NonZeroHashSet[{}]", RenderType(ty)),
                ty => todo!("compiler should catch invalid {ty:?} type"),
            },
            DataType::Tuple(types) => write!(f, "stef.Tuple{}{}", types.len(), Concat(types)),
            DataType::Array(ty, size) => write!(f, "[{size}]{}", RenderType(ty)),
            DataType::External(ExternalType {
                path,
                name,
                generics,
            }) => {
                if let Some(path) = path.last() {
                    write!(
                        f,
                        "{path}.{}{}",
                        heck::AsUpperCamelCase(name),
                        RenderGenericTypes(generics),
                    )
                } else {
                    write!(
                        f,
                        "{}{}",
                        heck::AsUpperCamelCase(name),
                        RenderGenericTypes(generics),
                    )
                }
            }
        }
    }
}

struct RenderConstType<'a>(&'a Type<'a>);

impl Display for RenderConstType<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.0.value {
            DataType::Bool => write!(f, "bool"),
            DataType::U8 => write!(f, "uint8"),
            DataType::U16 => write!(f, "uint16"),
            DataType::U32 => write!(f, "uint32"),
            DataType::U64 => write!(f, "uint64"),
            DataType::U128 | DataType::I128 => write!(f, "*big.Int"),
            DataType::I8 => write!(f, "int8"),
            DataType::I16 => write!(f, "int16"),
            DataType::I32 => write!(f, "int32"),
            DataType::I64 => write!(f, "int64"),
            DataType::F32 => write!(f, "float32"),
            DataType::F64 => write!(f, "float64"),
            DataType::String | DataType::StringRef => write!(f, "string"),
            DataType::Bytes | DataType::BytesRef => write!(f, "[]byte"),
            _ => panic!("invalid data type for const"),
        }
    }
}

struct Concat<'a, T>(&'a [T]);

impl<T> Display for Concat<'_, T>
where
    T: Display,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.0.is_empty() {
            return Ok(());
        }

        f.write_char('[')?;
        for (i, value) in self.0.iter().enumerate() {
            if i > 0 {
                f.write_str(", ")?;
            }
            value.fmt(f)?;
        }
        f.write_char(']')
    }
}

struct RenderConst<'a>(&'a Const<'a>);

impl Display for RenderConst<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let kind = if matches!(
            self.0.ty.value,
            DataType::Bool
                | DataType::U8
                | DataType::U16
                | DataType::U32
                | DataType::U64
                | DataType::I8
                | DataType::I16
                | DataType::I32
                | DataType::I64
                | DataType::F32
                | DataType::F64
                | DataType::String
                | DataType::StringRef
        ) {
            "const"
        } else {
            "var"
        };

        writeln!(
            f,
            "{}{kind} {} {} = {}",
            RenderComment {
                indent: 0,
                comment: &self.0.comment
            },
            heck::AsUpperCamelCase(&self.0.name),
            RenderConstType(&self.0.ty),
            RenderLiteral(&self.0.value),
        )
    }
}

struct RenderLiteral<'a>(&'a Literal);

impl Display for RenderLiteral<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.0 {
            Literal::Bool(b) => write!(f, "{b}"),
            Literal::Int(i) => write!(f, "{i}"),
            Literal::Float(f2) => write!(f, "{f2}"),
            Literal::String(s) => write!(f, "{s:?}"),
            Literal::Bytes(b) => {
                if b.is_empty() {
                    return Ok(());
                }

                f.write_str("[]byte{")?;
                for (i, value) in b.iter().enumerate() {
                    if i > 0 {
                        f.write_str(", ")?;
                    }
                    value.fmt(f)?;
                }
                f.write_char('}')
            }
        }
    }
}

struct RenderEnum<'a>(&'a Enum<'a>);

impl Display for RenderEnum<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            "type {}Variant interface {{",
            heck::AsUpperCamelCase(&self.0.name),
        )?;
        writeln!(f, "\t sealed()")?;
        writeln!(f, "}}")?;

        writeln!(
            f,
            "\n{}type {} {1}Variant",
            RenderComment {
                indent: 0,
                comment: &self.0.comment
            },
            heck::AsUpperCamelCase(&self.0.name),
        )?;

        for variant in &self.0.variants {
            write!(
                f,
                "\n{}",
                RenderEnumVariant {
                    enum_name: self.0.name.get(),
                    generics: &self.0.generics,
                    variant
                }
            )?;
        }

        Ok(())
    }
}

struct RenderEnumVariant<'a> {
    enum_name: &'a str,
    generics: &'a Generics<'a>,
    variant: &'a Variant<'a>,
}

impl Display for RenderEnumVariant<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            "{}type {}_{}{} {}",
            RenderComment {
                indent: 0,
                comment: &self.variant.comment
            },
            heck::AsUpperCamelCase(self.enum_name),
            heck::AsUpperCamelCase(&self.variant.name),
            RenderGenerics {
                generics: self.generics,
                fields_filter: Some(&self.variant.fields)
            },
            RenderFields(&self.variant.fields)
        )?;

        writeln!(
            f,
            "\nfunc (v {}_{}{}) sealed() {{}}",
            heck::AsUpperCamelCase(self.enum_name),
            heck::AsUpperCamelCase(&self.variant.name),
            RenderGenericNames {
                generics: self.generics,
                fields_filter: Some(&self.variant.fields),
            }
        )?;

        writeln!(
            f,
            "\n{}",
            RenderNewFunc {
                name: format_args!(
                    "{}_{}",
                    heck::AsUpperCamelCase(self.enum_name),
                    heck::AsUpperCamelCase(&self.variant.name)
                ),
                generics: self.generics,
                fields: &self.variant.fields,
                filter_generics: true,
            },
        )?;

        write!(
            f,
            "\n{}\n{}\n{}",
            encode::RenderEnumVariant {
                enum_name: self.enum_name,
                generics: self.generics,
                variant: self.variant,
            },
            decode::RenderEnumVariant {
                enum_name: self.enum_name,
                generics: self.generics,
                variant: self.variant,
            },
            size::RenderEnumVariant {
                enum_name: self.enum_name,
                generics: self.generics,
                variant: self.variant,
            },
        )
    }
}

fn uses_generic(generic: &Name<'_>, fields: &Fields<'_>) -> bool {
    fn visit_external(ty: &Type<'_>, visit: &impl Fn(&ExternalType<'_>) -> bool) -> bool {
        match &ty.value {
            DataType::Bool
            | DataType::U8
            | DataType::U16
            | DataType::U32
            | DataType::U64
            | DataType::U128
            | DataType::I8
            | DataType::I16
            | DataType::I32
            | DataType::I64
            | DataType::I128
            | DataType::F32
            | DataType::F64
            | DataType::String
            | DataType::StringRef
            | DataType::Bytes
            | DataType::BytesRef
            | DataType::BoxString
            | DataType::BoxBytes => false,
            DataType::Vec(ty)
            | DataType::HashSet(ty)
            | DataType::Option(ty)
            | DataType::NonZero(ty)
            | DataType::Array(ty, _) => visit_external(ty, visit),
            DataType::HashMap(kv) => visit_external(&kv.0, visit) || visit_external(&kv.1, visit),
            DataType::Tuple(types) => types.iter().any(|ty| visit_external(ty, visit)),
            DataType::External(ty) => visit(ty),
        }
    }

    let matches = |ext: &ExternalType<'_>| {
        ext.path.is_empty() && ext.generics.is_empty() && ext.name.get() == generic.get()
    };

    match fields {
        Fields::Named(named) => named
            .iter()
            .any(|field| visit_external(&field.ty, &matches)),
        Fields::Unnamed(unnamed) => unnamed
            .iter()
            .any(|field| visit_external(&field.ty, &matches)),
        Fields::Unit => false,
    }
}
