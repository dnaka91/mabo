---
source: crates/stef-go/tests/render.rs
description: "enum Sample<T>{One@1,Two(u32@1,u64@2,T@3)@2,Three{field1:u32@1,field2:bool@2,field3:T@3}@3}"
input_file: crates/stef-parser/tests/inputs/enum_min_ws.stef
---
--- sample.go

// Code generated by stef-go (v0.1.0). DO NOT EDIT.

import (
	"github.com/dnaka91/stef-go"
	"github.com/dnaka91/stef-go/buf"
)

package sample

type SampleVariant interface {
	 sealed()
}

type Sample SampleVariant

type Sample_One struct{}

func (v Sample_One) sealed() {}

func NewSample_One() Sample_One {
	return Sample_One{}
}

var _ buf.Encode = (*Sample_One)(nil)

func (v *Sample_One) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Sample_One)(nil)

func (v *Sample_One) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

type Sample_Two[T any] struct {
	F0 uint32
	F1 uint64
	F2 T
}

func (v Sample_Two[T]) sealed() {}

func NewSample_Two[T any](
	f0 uint32,
	f1 uint64,
	f2 T,
) Sample_Two[T] {
	return Sample_Two[T]{
		F0: f0,
		F1: f1,
		F2: f2,
	}
}

var _ buf.Encode = (*Sample_Two[T])(nil)

func (v *Sample_Two[T]) Encode(w []byte) []byte {
	w = buf.EncodeField(w, 1, func (w []byte) []byte {
		return buf.EncodeU32(w, v.F0)
	})
	w = buf.EncodeField(w, 2, func (w []byte) []byte {
		return buf.EncodeU64(w, v.F1)
	})
	w = buf.EncodeField(w, 3, func (w []byte) []byte {
		return v.F2.Encode(w)
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return nil
}

var _ buf.Decode = (*Sample_Two[T])(nil)

func (v *Sample_Two[T]) Decode(r []byte) ([]byte, error) {
	foundF0 := false
	foundF1 := false
	foundF2 := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := buf.DecodeU32(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.F0 = value
				foundF0 = true
			case 2:
				r2, value, err := buf.DecodeU64(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.F1 = value
				foundF1 = true
			case 3:
				r2, value, err := func(r []byte) ([]byte, T, error) {
					var value T
					return value.Decode(r)
				}(r)

				if err != nil {
					return nil, err
				}
				r = r2
				v.F2 = value
				foundF2 = true
			case buf.EndMarker:
				break
		}
	}

	if !foundF0 {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: ""
		}
	}
	if !foundF1 {
		return nil, buf.MissingFieldError{
			ID:    2
			Field: ""
		}
	}
	if !foundF2 {
		return nil, buf.MissingFieldError{
			ID:    3
			Field: ""
		}
	}

	return r, nil
}

type Sample_Three[T any] struct {
	Field1 uint32
	Field2 bool
	Field3 T
}

func (v Sample_Three[T]) sealed() {}

func NewSample_Three[T any](
	field1 uint32,
	field2 bool,
	field3 T,
) Sample_Three[T] {
	return Sample_Three[T]{
		Field1: field1,
		Field2: field2,
		Field3: field3,
	}
}

var _ buf.Encode = (*Sample_Three[T])(nil)

func (v *Sample_Three[T]) Encode(w []byte) []byte {
	w = buf.EncodeField(w, 1, func (w []byte) []byte {
		return buf.EncodeU32(w, v.Field1)
	})
	w = buf.EncodeField(w, 2, func (w []byte) []byte {
		return buf.EncodeBool(w, v.Field2)
	})
	w = buf.EncodeField(w, 3, func (w []byte) []byte {
		return v.Field3.Encode(w)
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return nil
}

var _ buf.Decode = (*Sample_Three[T])(nil)

func (v *Sample_Three[T]) Decode(r []byte) ([]byte, error) {
	foundField1 := false
	foundField2 := false
	foundField3 := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := buf.DecodeU32(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.Field1 = value
				foundField1 = true
			case 2:
				r2, value, err := buf.DecodeBool(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.Field2 = value
				foundField2 = true
			case 3:
				r2, value, err := func(r []byte) ([]byte, T, error) {
					var value T
					return value.Decode(r)
				}(r)

				if err != nil {
					return nil, err
				}
				r = r2
				v.Field3 = value
				foundField3 = true
			case buf.EndMarker:
				break
		}
	}

	if !foundField1 {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: "field1"
		}
	}
	if !foundField2 {
		return nil, buf.MissingFieldError{
			ID:    2
			Field: "field2"
		}
	}
	if !foundField3 {
		return nil, buf.MissingFieldError{
			ID:    3
			Field: "field3"
		}
	}

	return r, nil
}


