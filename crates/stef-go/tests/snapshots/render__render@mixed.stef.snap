---
source: crates/stef-go/tests/render.rs
description: "/// Schema with a bit of everything, to try out more complex scenarios.\n\n/// Basic user information.\n///\n/// Uses various other `structs` and `enums` to compose the information\n/// in a **type safe** way.\nstruct User {\n    name: FullName @1,\n    /// Physical address, might not be specified by the user.\n    address: option<Address> @2,\n    age: u8 @3,\n    birthday: birthday::DayOfBirth @4,\n}\n\n/// Full name of a user.\nstruct FullName {\n    first: string @1,\n    middle: option<string> @2,\n    last: string @3,\n}\n\n/// Simple alias for convenience.\n///\n/// - Might be easier to remember.\n/// - Often referenced as this.\ntype Name = FullName;\n\nstruct Address {\n    /// Street name.\n    street: string @1,\n    /// Number of the house in the street.\n    house_no: HouseNumber @2,\n    city: string @3,\n}\n\n/// The number on the house.\n///\n/// More details can be found at [Wikipedia](https://en.wikipedia.org/wiki/House_numbering).\nenum HouseNumber {\n    /// Digit only number.\n    Digit(u16 @1) @1,\n    /// Mixed _number_ with characters like `1a`.\n    Text(string @1) @2,\n}\n\n/// Probably the max age of a human, currently.\nconst MAX_AGE: u8 = 120;\n\n\n/// Details for defining birthdays.\nmod birthday {\n    /// As the name suggests, specifies details about birthdays.\n    enum DayOfBirth {\n        Specific {\n            year: u16 @1,\n            month: Month @2,\n            day: u8 @3,\n        } @1,\n        /// The user didn't want to say.\n        Secret {\n            /// Optional info from the user about why they didn't want to\n            /// reveal their birthday.\n            reason: option<string> @1,\n        } @2,\n        /// We never asked and nobody knows.\n        Unknown @3,\n    }\n\n    /// Let's assume we only have details of people born **after** this year.\n    const MIN_YEAR: u16 = 1900;\n\n    /// Absolute maximum for a day, but might be even less depending\n    /// on the month.\n    const MAX_DAY: u8 = 31;\n\n    /// The month of the year.\n    enum Month {\n        January @1,\n        February @2,\n        March @3,\n        April @4,\n        May @5,\n        June @6,\n        July @7,\n        August @8,\n        September @9,\n        October @10,\n        November @11,\n        December @12,\n    }\n}"
input_file: crates/stef-parser/tests/inputs/mixed.stef
---
--- sample.go

// Code generated by stef-go (v0.1.0). DO NOT EDIT.

import (
	"github.com/dnaka91/stef-go"
	"github.com/dnaka91/stef-go/buf"
)

package sample

// Basic user information.
// 
// Uses various other `structs` and `enums` to compose the information
// in a **type safe** way.
type User struct {
	Name FullName
	// Physical address, might not be specified by the user.
	Address *Address
	Age uint8
	Birthday birthday.DayOfBirth
}

func NewUser(
	name FullName,
	address *Address,
	age uint8,
	birthday birthday.DayOfBirth,
) User {
	return User{
		Name: name,
		Address: address,
		Age: age,
		Birthday: birthday,
	}
}

var _ buf.Encode = (*User)(nil)

func (v *User) Encode(w []byte) []byte {
	w = buf.EncodeField(w, 1, func (w []byte) []byte {
		return v.Name.Encode(w)
	})
	w = buf.EncodeFieldOption[Address](w, 2, &v.Address, func (w []byte, v Address) []byte {
		return v.Encode(w)
	})
	w = buf.EncodeField(w, 3, func (w []byte) []byte {
		return buf.EncodeU8(w, v.Age)
	})
	w = buf.EncodeField(w, 4, func (w []byte) []byte {
		return v.Birthday.Encode(w)
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return w
}

var _ buf.Decode = (*User)(nil)

func (v *User) Decode(r []byte) ([]byte, error) {
	foundName := false
	foundAddress := false
	foundAge := false
	foundBirthday := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := func(r []byte) ([]byte, FullName, error) {
					var value FullName
					return value.Decode(r)
				}(r)

				if err != nil {
					return nil, err
				}
				r = r2
				v.Name = value
				foundName = true
			case 2:
				r2, value, err := buf.DecodeOption[Address](r, func(r []byte) ([]byte, Address, error) {
					return func(r []byte) ([]byte, Address, error) {
						var value Address
						return value.Decode(r)
					}(r)

				})
				if err != nil {
					return nil, err
				}
				r = r2
				v.Address = value
				foundAddress = true
			case 3:
				r2, value, err := buf.DecodeU8(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.Age = value
				foundAge = true
			case 4:
				r2, value, err := func(r []byte) ([]byte, birthday.DayOfBirth, error) {
					var value birthday.DayOfBirth
					return value.Decode(r)
				}(r)

				if err != nil {
					return nil, err
				}
				r = r2
				v.Birthday = value
				foundBirthday = true
			case buf.EndMarker:
				break
		}
	}

	if !foundName {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: "name"
		}
	}
	if !foundAddress {
		return nil, buf.MissingFieldError{
			ID:    2
			Field: "address"
		}
	}
	if !foundAge {
		return nil, buf.MissingFieldError{
			ID:    3
			Field: "age"
		}
	}
	if !foundBirthday {
		return nil, buf.MissingFieldError{
			ID:    4
			Field: "birthday"
		}
	}

	return r, nil
}

var _ buf.Size = (*User)(nil)

func (v *User) Size() int {
	size := 0
	size += buf.SizeField(1, func() int {
		return v.Name.Size()
	})
	size += buf.SizeFieldOption[Address](2, &v.Address, func (v Address) int {
		return v.Size()
	})
	size += buf.SizeField(3, func() int {
		return buf.SizeU8(v.Age)
	})
	size += buf.SizeField(4, func() int {
		return v.Birthday.Size()
	})
	size += buf.SizeU32(buf.EndMarker)
	return size
}

// Full name of a user.
type FullName struct {
	First string
	Middle *string
	Last string
}

func NewFullName(
	first string,
	middle *string,
	last string,
) FullName {
	return FullName{
		First: first,
		Middle: middle,
		Last: last,
	}
}

var _ buf.Encode = (*FullName)(nil)

func (v *FullName) Encode(w []byte) []byte {
	w = buf.EncodeField(w, 1, func (w []byte) []byte {
		return buf.EncodeString(w, v.First)
	})
	w = buf.EncodeFieldOption[string](w, 2, &v.Middle, func (w []byte, v string) []byte {
		return buf.EncodeString(w, v)
	})
	w = buf.EncodeField(w, 3, func (w []byte) []byte {
		return buf.EncodeString(w, v.Last)
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return w
}

var _ buf.Decode = (*FullName)(nil)

func (v *FullName) Decode(r []byte) ([]byte, error) {
	foundFirst := false
	foundMiddle := false
	foundLast := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := buf.DecodeString(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.First = value
				foundFirst = true
			case 2:
				r2, value, err := buf.DecodeOption[string](r, func(r []byte) ([]byte, string, error) {
					return buf.DecodeString(r)
				})
				if err != nil {
					return nil, err
				}
				r = r2
				v.Middle = value
				foundMiddle = true
			case 3:
				r2, value, err := buf.DecodeString(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.Last = value
				foundLast = true
			case buf.EndMarker:
				break
		}
	}

	if !foundFirst {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: "first"
		}
	}
	if !foundMiddle {
		return nil, buf.MissingFieldError{
			ID:    2
			Field: "middle"
		}
	}
	if !foundLast {
		return nil, buf.MissingFieldError{
			ID:    3
			Field: "last"
		}
	}

	return r, nil
}

var _ buf.Size = (*FullName)(nil)

func (v *FullName) Size() int {
	size := 0
	size += buf.SizeField(1, func() int {
		return buf.SizeString(v.First)
	})
	size += buf.SizeFieldOption[string](2, &v.Middle, func (v string) int {
		return buf.SizeString(v)
	})
	size += buf.SizeField(3, func() int {
		return buf.SizeString(v.Last)
	})
	size += buf.SizeU32(buf.EndMarker)
	return size
}

// Simple alias for convenience.
// 
// - Might be easier to remember.
// - Often referenced as this.
type Name FullName

type Address struct {
	// Street name.
	Street string
	// Number of the house in the street.
	HouseNo HouseNumber
	City string
}

func NewAddress(
	street string,
	houseNo HouseNumber,
	city string,
) Address {
	return Address{
		Street: street,
		HouseNo: houseNo,
		City: city,
	}
}

var _ buf.Encode = (*Address)(nil)

func (v *Address) Encode(w []byte) []byte {
	w = buf.EncodeField(w, 1, func (w []byte) []byte {
		return buf.EncodeString(w, v.Street)
	})
	w = buf.EncodeField(w, 2, func (w []byte) []byte {
		return v.HouseNo.Encode(w)
	})
	w = buf.EncodeField(w, 3, func (w []byte) []byte {
		return buf.EncodeString(w, v.City)
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return w
}

var _ buf.Decode = (*Address)(nil)

func (v *Address) Decode(r []byte) ([]byte, error) {
	foundStreet := false
	foundHouseNo := false
	foundCity := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := buf.DecodeString(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.Street = value
				foundStreet = true
			case 2:
				r2, value, err := func(r []byte) ([]byte, HouseNumber, error) {
					var value HouseNumber
					return value.Decode(r)
				}(r)

				if err != nil {
					return nil, err
				}
				r = r2
				v.HouseNo = value
				foundHouseNo = true
			case 3:
				r2, value, err := buf.DecodeString(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.City = value
				foundCity = true
			case buf.EndMarker:
				break
		}
	}

	if !foundStreet {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: "street"
		}
	}
	if !foundHouseNo {
		return nil, buf.MissingFieldError{
			ID:    2
			Field: "house_no"
		}
	}
	if !foundCity {
		return nil, buf.MissingFieldError{
			ID:    3
			Field: "city"
		}
	}

	return r, nil
}

var _ buf.Size = (*Address)(nil)

func (v *Address) Size() int {
	size := 0
	size += buf.SizeField(1, func() int {
		return buf.SizeString(v.Street)
	})
	size += buf.SizeField(2, func() int {
		return v.HouseNo.Size()
	})
	size += buf.SizeField(3, func() int {
		return buf.SizeString(v.City)
	})
	size += buf.SizeU32(buf.EndMarker)
	return size
}

type HouseNumberVariant interface {
	 sealed()
}

// The number on the house.
// 
// More details can be found at [Wikipedia](https://en.wikipedia.org/wiki/House_numbering).
type HouseNumber HouseNumberVariant

// Digit only number.
type HouseNumber_Digit struct {
	N0 uint16
}

func (v HouseNumber_Digit) sealed() {}

func NewHouseNumber_Digit(
	n0 uint16,
) HouseNumber_Digit {
	return HouseNumber_Digit{
		N0: n0,
	}
}

var _ buf.Encode = (*HouseNumber_Digit)(nil)

func (v *HouseNumber_Digit) Encode(w []byte) []byte {
	w = buf.EncodeField(w, 1, func (w []byte) []byte {
		return buf.EncodeU16(w, v.N0)
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return nil
}

var _ buf.Decode = (*HouseNumber_Digit)(nil)

func (v *HouseNumber_Digit) Decode(r []byte) ([]byte, error) {
	foundN0 := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := buf.DecodeU16(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.N0 = value
				foundN0 = true
			case buf.EndMarker:
				break
		}
	}

	if !foundN0 {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: ""
		}
	}

	return r, nil
}

var _ buf.Size = (*HouseNumber_Digit)(nil)

func (v *HouseNumber_Digit) Size() int {
	size := 0
	size += buf.SizeField(1, func() int {
		return buf.SizeU16(v.N0)
	})
	size += buf.SizeU32(buf.EndMarker)
	return size
}

// Mixed _number_ with characters like `1a`.
type HouseNumber_Text struct {
	N0 string
}

func (v HouseNumber_Text) sealed() {}

func NewHouseNumber_Text(
	n0 string,
) HouseNumber_Text {
	return HouseNumber_Text{
		N0: n0,
	}
}

var _ buf.Encode = (*HouseNumber_Text)(nil)

func (v *HouseNumber_Text) Encode(w []byte) []byte {
	w = buf.EncodeField(w, 1, func (w []byte) []byte {
		return buf.EncodeString(w, v.N0)
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return nil
}

var _ buf.Decode = (*HouseNumber_Text)(nil)

func (v *HouseNumber_Text) Decode(r []byte) ([]byte, error) {
	foundN0 := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := buf.DecodeString(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.N0 = value
				foundN0 = true
			case buf.EndMarker:
				break
		}
	}

	if !foundN0 {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: ""
		}
	}

	return r, nil
}

var _ buf.Size = (*HouseNumber_Text)(nil)

func (v *HouseNumber_Text) Size() int {
	size := 0
	size += buf.SizeField(1, func() int {
		return buf.SizeString(v.N0)
	})
	size += buf.SizeU32(buf.EndMarker)
	return size
}

// Probably the max age of a human, currently.
const MaxAge uint8 = 120
--- sample/birthday.go

// Code generated by stef-go (v0.1.0). DO NOT EDIT.

// Details for defining birthdays.
package birthday

type DayOfBirthVariant interface {
	 sealed()
}

// As the name suggests, specifies details about birthdays.
type DayOfBirth DayOfBirthVariant

type DayOfBirth_Specific struct {
	Year uint16
	Month Month
	Day uint8
}

func (v DayOfBirth_Specific) sealed() {}

func NewDayOfBirth_Specific(
	year uint16,
	month Month,
	day uint8,
) DayOfBirth_Specific {
	return DayOfBirth_Specific{
		Year: year,
		Month: month,
		Day: day,
	}
}

var _ buf.Encode = (*DayOfBirth_Specific)(nil)

func (v *DayOfBirth_Specific) Encode(w []byte) []byte {
	w = buf.EncodeField(w, 1, func (w []byte) []byte {
		return buf.EncodeU16(w, v.Year)
	})
	w = buf.EncodeField(w, 2, func (w []byte) []byte {
		return v.Month.Encode(w)
	})
	w = buf.EncodeField(w, 3, func (w []byte) []byte {
		return buf.EncodeU8(w, v.Day)
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return nil
}

var _ buf.Decode = (*DayOfBirth_Specific)(nil)

func (v *DayOfBirth_Specific) Decode(r []byte) ([]byte, error) {
	foundYear := false
	foundMonth := false
	foundDay := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := buf.DecodeU16(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.Year = value
				foundYear = true
			case 2:
				r2, value, err := func(r []byte) ([]byte, Month, error) {
					var value Month
					return value.Decode(r)
				}(r)

				if err != nil {
					return nil, err
				}
				r = r2
				v.Month = value
				foundMonth = true
			case 3:
				r2, value, err := buf.DecodeU8(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.Day = value
				foundDay = true
			case buf.EndMarker:
				break
		}
	}

	if !foundYear {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: "year"
		}
	}
	if !foundMonth {
		return nil, buf.MissingFieldError{
			ID:    2
			Field: "month"
		}
	}
	if !foundDay {
		return nil, buf.MissingFieldError{
			ID:    3
			Field: "day"
		}
	}

	return r, nil
}

var _ buf.Size = (*DayOfBirth_Specific)(nil)

func (v *DayOfBirth_Specific) Size() int {
	size := 0
	size += buf.SizeField(1, func() int {
		return buf.SizeU16(v.Year)
	})
	size += buf.SizeField(2, func() int {
		return v.Month.Size()
	})
	size += buf.SizeField(3, func() int {
		return buf.SizeU8(v.Day)
	})
	size += buf.SizeU32(buf.EndMarker)
	return size
}

// The user didn't want to say.
type DayOfBirth_Secret struct {
	// Optional info from the user about why they didn't want to
	// reveal their birthday.
	Reason *string
}

func (v DayOfBirth_Secret) sealed() {}

func NewDayOfBirth_Secret(
	reason *string,
) DayOfBirth_Secret {
	return DayOfBirth_Secret{
		Reason: reason,
	}
}

var _ buf.Encode = (*DayOfBirth_Secret)(nil)

func (v *DayOfBirth_Secret) Encode(w []byte) []byte {
	w = buf.EncodeFieldOption[string](w, 1, &v.Reason, func (w []byte, v string) []byte {
		return buf.EncodeString(w, v)
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return nil
}

var _ buf.Decode = (*DayOfBirth_Secret)(nil)

func (v *DayOfBirth_Secret) Decode(r []byte) ([]byte, error) {
	foundReason := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := buf.DecodeOption[string](r, func(r []byte) ([]byte, string, error) {
					return buf.DecodeString(r)
				})
				if err != nil {
					return nil, err
				}
				r = r2
				v.Reason = value
				foundReason = true
			case buf.EndMarker:
				break
		}
	}

	if !foundReason {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: "reason"
		}
	}

	return r, nil
}

var _ buf.Size = (*DayOfBirth_Secret)(nil)

func (v *DayOfBirth_Secret) Size() int {
	size := 0
	size += buf.SizeFieldOption[string](1, &v.Reason, func (v string) int {
		return buf.SizeString(v)
	})
	size += buf.SizeU32(buf.EndMarker)
	return size
}

// We never asked and nobody knows.
type DayOfBirth_Unknown struct{}

func (v DayOfBirth_Unknown) sealed() {}

func NewDayOfBirth_Unknown() DayOfBirth_Unknown {
	return DayOfBirth_Unknown{}
}

var _ buf.Encode = (*DayOfBirth_Unknown)(nil)

func (v *DayOfBirth_Unknown) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*DayOfBirth_Unknown)(nil)

func (v *DayOfBirth_Unknown) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*DayOfBirth_Unknown)(nil)

func (v *DayOfBirth_Unknown) Size() int {
	size := 0
	return size
}

// Let's assume we only have details of people born **after** this year.
const MinYear uint16 = 1900
// Absolute maximum for a day, but might be even less depending
// on the month.
const MaxDay uint8 = 31
type MonthVariant interface {
	 sealed()
}

// The month of the year.
type Month MonthVariant

type Month_January struct{}

func (v Month_January) sealed() {}

func NewMonth_January() Month_January {
	return Month_January{}
}

var _ buf.Encode = (*Month_January)(nil)

func (v *Month_January) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Month_January)(nil)

func (v *Month_January) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Month_January)(nil)

func (v *Month_January) Size() int {
	size := 0
	return size
}

type Month_February struct{}

func (v Month_February) sealed() {}

func NewMonth_February() Month_February {
	return Month_February{}
}

var _ buf.Encode = (*Month_February)(nil)

func (v *Month_February) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Month_February)(nil)

func (v *Month_February) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Month_February)(nil)

func (v *Month_February) Size() int {
	size := 0
	return size
}

type Month_March struct{}

func (v Month_March) sealed() {}

func NewMonth_March() Month_March {
	return Month_March{}
}

var _ buf.Encode = (*Month_March)(nil)

func (v *Month_March) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Month_March)(nil)

func (v *Month_March) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Month_March)(nil)

func (v *Month_March) Size() int {
	size := 0
	return size
}

type Month_April struct{}

func (v Month_April) sealed() {}

func NewMonth_April() Month_April {
	return Month_April{}
}

var _ buf.Encode = (*Month_April)(nil)

func (v *Month_April) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Month_April)(nil)

func (v *Month_April) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Month_April)(nil)

func (v *Month_April) Size() int {
	size := 0
	return size
}

type Month_May struct{}

func (v Month_May) sealed() {}

func NewMonth_May() Month_May {
	return Month_May{}
}

var _ buf.Encode = (*Month_May)(nil)

func (v *Month_May) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Month_May)(nil)

func (v *Month_May) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Month_May)(nil)

func (v *Month_May) Size() int {
	size := 0
	return size
}

type Month_June struct{}

func (v Month_June) sealed() {}

func NewMonth_June() Month_June {
	return Month_June{}
}

var _ buf.Encode = (*Month_June)(nil)

func (v *Month_June) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Month_June)(nil)

func (v *Month_June) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Month_June)(nil)

func (v *Month_June) Size() int {
	size := 0
	return size
}

type Month_July struct{}

func (v Month_July) sealed() {}

func NewMonth_July() Month_July {
	return Month_July{}
}

var _ buf.Encode = (*Month_July)(nil)

func (v *Month_July) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Month_July)(nil)

func (v *Month_July) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Month_July)(nil)

func (v *Month_July) Size() int {
	size := 0
	return size
}

type Month_August struct{}

func (v Month_August) sealed() {}

func NewMonth_August() Month_August {
	return Month_August{}
}

var _ buf.Encode = (*Month_August)(nil)

func (v *Month_August) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Month_August)(nil)

func (v *Month_August) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Month_August)(nil)

func (v *Month_August) Size() int {
	size := 0
	return size
}

type Month_September struct{}

func (v Month_September) sealed() {}

func NewMonth_September() Month_September {
	return Month_September{}
}

var _ buf.Encode = (*Month_September)(nil)

func (v *Month_September) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Month_September)(nil)

func (v *Month_September) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Month_September)(nil)

func (v *Month_September) Size() int {
	size := 0
	return size
}

type Month_October struct{}

func (v Month_October) sealed() {}

func NewMonth_October() Month_October {
	return Month_October{}
}

var _ buf.Encode = (*Month_October)(nil)

func (v *Month_October) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Month_October)(nil)

func (v *Month_October) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Month_October)(nil)

func (v *Month_October) Size() int {
	size := 0
	return size
}

type Month_November struct{}

func (v Month_November) sealed() {}

func NewMonth_November() Month_November {
	return Month_November{}
}

var _ buf.Encode = (*Month_November)(nil)

func (v *Month_November) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Month_November)(nil)

func (v *Month_November) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Month_November)(nil)

func (v *Month_November) Size() int {
	size := 0
	return size
}

type Month_December struct{}

func (v Month_December) sealed() {}

func NewMonth_December() Month_December {
	return Month_December{}
}

var _ buf.Encode = (*Month_December)(nil)

func (v *Month_December) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Month_December)(nil)

func (v *Month_December) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Month_December)(nil)

func (v *Month_December) Size() int {
	size := 0
	return size
}


