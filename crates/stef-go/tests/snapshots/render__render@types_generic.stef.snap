---
source: crates/stef-go/tests/render.rs
description: "struct Sample {\n    f1: vec<u32> @1,\n    f2: hash_map<u32, string> @2,\n    f3: hash_set<u32> @3,\n    f4: option<u32> @4,\n    f5: non_zero<u32> @5,\n}\n\nstruct SampleUnnamed(\n    vec<u32> @1,\n    hash_map<u32, string> @2,\n    hash_set<u32> @3,\n    option<u32> @4,\n    non_zero<u32> @5,\n)"
input_file: crates/stef-parser/tests/inputs/types_generic.stef
---
--- sample.go

// Code generated by stef-go (v0.1.0). DO NOT EDIT.

import (
	"github.com/dnaka91/stef-go"
	"github.com/dnaka91/stef-go/buf"
)

package sample

type Sample struct {
	F1 []uint32
	F2 map[uint32]string
	F3 map[uint32]struct{}
	F4 *uint32
	F5 stef.NonZeroU32
}

func NewSample(
	f1 []uint32,
	f2 map[uint32]string,
	f3 map[uint32]struct{},
	f4 *uint32,
	f5 stef.NonZeroU32,
) Sample {
	return Sample{
		F1: f1,
		F2: f2,
		F3: f3,
		F4: f4,
		F5: f5,
	}
}

var _ buf.Encode = (*Sample)(nil)

func (v *Sample) Encode(w []byte) []byte {
	w = buf.EncodeField(w, 1, func (w []byte) []byte {
		return buf.EncodeVec[uint32](w, v.F1, func(w []byte, v uint32) []byte {
			return buf.EncodeU32(w, v)
		})
	})
	w = buf.EncodeField(w, 2, func (w []byte) []byte {
		return buf.EncodeHashMap[uint32, string](
			w, v.F2,
			func(w []byte, k uint32) []byte {
				return buf.EncodeU32(w, k)
			},
			func(w []byte, v string) []byte {
				return buf.EncodeString(w, v)
			},
		)
	})
	w = buf.EncodeField(w, 3, func (w []byte) []byte {
		return buf.EncodeHashSet[uint32](w, v.F3, func(w []byte, v uint32) []byte {
			return buf.EncodeU32(w, v)
		})
	})
	w = buf.EncodeFieldOption[uint32](w, 4, &v.F4, func (w []byte, v uint32) []byte {
		return buf.EncodeU32(w, v)
	})
	w = buf.EncodeField(w, 5, func (w []byte) []byte {
		return buf.EncodeU32(w, v.F5.Get())
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return w
}

var _ buf.Decode = (*Sample)(nil)

func (v *Sample) Decode(r []byte) ([]byte, error) {
	foundF1 := false
	foundF2 := false
	foundF3 := false
	foundF4 := false
	foundF5 := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := buf.DecodeVec[uint32](r, func(r []byte) ([]byte, uint32, error) {
					return buf.DecodeU32(r)
				})
				if err != nil {
					return nil, err
				}
				r = r2
				v.F1 = value
				foundF1 = true
			case 2:
				r2, value, err := buf.DecodeHashMap[uint32, string](
					r,
					func(r []byte) ([]byte, uint32, error) {
						return buf.DecodeU32(r)
					},
					func(r []byte) ([]byte, string, error) {
						return buf.DecodeString(r)
					},
				)
				if err != nil {
					return nil, err
				}
				r = r2
				v.F2 = value
				foundF2 = true
			case 3:
				r2, value, err := buf.DecodeHashSet[uint32](r, func(r []byte) ([]byte, uint32, error) {
					return buf.DecodeU32(r)
				})
				if err != nil {
					return nil, err
				}
				r = r2
				v.F3 = value
				foundF3 = true
			case 4:
				r2, value, err := buf.DecodeOption[uint32](r, func(r []byte) ([]byte, uint32, error) {
					return buf.DecodeU32(r)
				})
				if err != nil {
					return nil, err
				}
				r = r2
				v.F4 = value
				foundF4 = true
			case 5:
				r2, value, err := buf.DecodeNonZeroU32(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.F5 = value
				foundF5 = true
			case buf.EndMarker:
				break
		}
	}

	if !foundF1 {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: "f1"
		}
	}
	if !foundF2 {
		return nil, buf.MissingFieldError{
			ID:    2
			Field: "f2"
		}
	}
	if !foundF3 {
		return nil, buf.MissingFieldError{
			ID:    3
			Field: "f3"
		}
	}
	if !foundF4 {
		return nil, buf.MissingFieldError{
			ID:    4
			Field: "f4"
		}
	}
	if !foundF5 {
		return nil, buf.MissingFieldError{
			ID:    5
			Field: "f5"
		}
	}

	return r, nil
}

var _ buf.Size = (*Sample)(nil)

func (v *Sample) Size() int {
	size := 0
	size += buf.SizeField(1, func() int {
		return buf.SizeVec[uint32](v.F1, func(v uint32) int {
			return buf.SizeU32(v)
		})
	})
	size += buf.SizeField(2, func() int {
		return buf.SizeHashMap[uint32, string](
			v.F2,
			func(k uint32) int {
				return buf.SizeU32(k)
			},
			func(v string) int {
				return buf.SizeString(v)
			},
		)
	})
	size += buf.SizeField(3, func() int {
		return buf.SizeHashSet[uint32](v.F3, func(v uint32) int {
			return buf.SizeU32(v)
		})
	})
	size += buf.SizeFieldOption[uint32](4, &v.F4, func (v uint32) int {
		return buf.SizeU32(v)
	})
	size += buf.SizeField(5, func() int {
		return buf.SizeU32(v.F5.Get())
	})
	size += buf.SizeU32(buf.EndMarker)
	return size
}

type SampleUnnamed struct {
	N0 []uint32
	N1 map[uint32]string
	N2 map[uint32]struct{}
	N3 *uint32
	N4 stef.NonZeroU32
}

func NewSampleUnnamed(
	n0 []uint32,
	n1 map[uint32]string,
	n2 map[uint32]struct{},
	n3 *uint32,
	n4 stef.NonZeroU32,
) SampleUnnamed {
	return SampleUnnamed{
		N0: n0,
		N1: n1,
		N2: n2,
		N3: n3,
		N4: n4,
	}
}

var _ buf.Encode = (*SampleUnnamed)(nil)

func (v *SampleUnnamed) Encode(w []byte) []byte {
	w = buf.EncodeField(w, 1, func (w []byte) []byte {
		return buf.EncodeVec[uint32](w, v.N0, func(w []byte, v uint32) []byte {
			return buf.EncodeU32(w, v)
		})
	})
	w = buf.EncodeField(w, 2, func (w []byte) []byte {
		return buf.EncodeHashMap[uint32, string](
			w, v.N1,
			func(w []byte, k uint32) []byte {
				return buf.EncodeU32(w, k)
			},
			func(w []byte, v string) []byte {
				return buf.EncodeString(w, v)
			},
		)
	})
	w = buf.EncodeField(w, 3, func (w []byte) []byte {
		return buf.EncodeHashSet[uint32](w, v.N2, func(w []byte, v uint32) []byte {
			return buf.EncodeU32(w, v)
		})
	})
	w = buf.EncodeFieldOption[uint32](w, 4, &v.N3, func (w []byte, v uint32) []byte {
		return buf.EncodeU32(w, v)
	})
	w = buf.EncodeField(w, 5, func (w []byte) []byte {
		return buf.EncodeU32(w, v.N4.Get())
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return w
}

var _ buf.Decode = (*SampleUnnamed)(nil)

func (v *SampleUnnamed) Decode(r []byte) ([]byte, error) {
	foundN0 := false
	foundN1 := false
	foundN2 := false
	foundN3 := false
	foundN4 := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := buf.DecodeVec[uint32](r, func(r []byte) ([]byte, uint32, error) {
					return buf.DecodeU32(r)
				})
				if err != nil {
					return nil, err
				}
				r = r2
				v.N0 = value
				foundN0 = true
			case 2:
				r2, value, err := buf.DecodeHashMap[uint32, string](
					r,
					func(r []byte) ([]byte, uint32, error) {
						return buf.DecodeU32(r)
					},
					func(r []byte) ([]byte, string, error) {
						return buf.DecodeString(r)
					},
				)
				if err != nil {
					return nil, err
				}
				r = r2
				v.N1 = value
				foundN1 = true
			case 3:
				r2, value, err := buf.DecodeHashSet[uint32](r, func(r []byte) ([]byte, uint32, error) {
					return buf.DecodeU32(r)
				})
				if err != nil {
					return nil, err
				}
				r = r2
				v.N2 = value
				foundN2 = true
			case 4:
				r2, value, err := buf.DecodeOption[uint32](r, func(r []byte) ([]byte, uint32, error) {
					return buf.DecodeU32(r)
				})
				if err != nil {
					return nil, err
				}
				r = r2
				v.N3 = value
				foundN3 = true
			case 5:
				r2, value, err := buf.DecodeNonZeroU32(r)
				if err != nil {
					return nil, err
				}
				r = r2
				v.N4 = value
				foundN4 = true
			case buf.EndMarker:
				break
		}
	}

	if !foundN0 {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: ""
		}
	}
	if !foundN1 {
		return nil, buf.MissingFieldError{
			ID:    2
			Field: ""
		}
	}
	if !foundN2 {
		return nil, buf.MissingFieldError{
			ID:    3
			Field: ""
		}
	}
	if !foundN3 {
		return nil, buf.MissingFieldError{
			ID:    4
			Field: ""
		}
	}
	if !foundN4 {
		return nil, buf.MissingFieldError{
			ID:    5
			Field: ""
		}
	}

	return r, nil
}

var _ buf.Size = (*SampleUnnamed)(nil)

func (v *SampleUnnamed) Size() int {
	size := 0
	size += buf.SizeField(1, func() int {
		return buf.SizeVec[uint32](v.N0, func(v uint32) int {
			return buf.SizeU32(v)
		})
	})
	size += buf.SizeField(2, func() int {
		return buf.SizeHashMap[uint32, string](
			v.N1,
			func(k uint32) int {
				return buf.SizeU32(k)
			},
			func(v string) int {
				return buf.SizeString(v)
			},
		)
	})
	size += buf.SizeField(3, func() int {
		return buf.SizeHashSet[uint32](v.N2, func(v uint32) int {
			return buf.SizeU32(v)
		})
	})
	size += buf.SizeFieldOption[uint32](4, &v.N3, func (v uint32) int {
		return buf.SizeU32(v)
	})
	size += buf.SizeField(5, func() int {
		return buf.SizeU32(v.N4.Get())
	})
	size += buf.SizeU32(buf.EndMarker)
	return size
}


