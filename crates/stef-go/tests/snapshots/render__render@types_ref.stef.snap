---
source: crates/stef-go/tests/render.rs
description: "struct Sample {\n    basic: Test123 @1,\n    with_generics: KeyValue<u32, bool> @2,\n}\n\nenum Test123 {\n    Value @1,\n}\n\nstruct KeyValue<K, V> {\n    key: K @1,\n    value: V @2,\n}"
input_file: crates/stef-parser/tests/inputs/types_ref.stef
---
--- sample.go

// Code generated by stef-go (v0.1.0). DO NOT EDIT.

import (
	"github.com/dnaka91/stef-go"
	"github.com/dnaka91/stef-go/buf"
)

package sample

type Sample struct {
	Basic Test123
	WithGenerics KeyValue[uint32, bool]
}

func NewSample(
	basic Test123,
	withGenerics KeyValue[uint32, bool],
) Sample {
	return Sample{
		Basic: basic,
		WithGenerics: withGenerics,
	}
}

var _ buf.Encode = (*Sample)(nil)

func (v *Sample) Encode(w []byte) []byte {
	w = buf.EncodeField(w, 1, func (w []byte) []byte {
		return v.Basic.Encode(w)
	})
	w = buf.EncodeField(w, 2, func (w []byte) []byte {
		return v.WithGenerics.Encode(w)
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return w
}

var _ buf.Decode = (*Sample)(nil)

func (v *Sample) Decode(r []byte) ([]byte, error) {
	foundBasic := false
	foundWithGenerics := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := func(r []byte) ([]byte, Test123, error) {
					var value Test123
					return value.Decode(r)
				}(r)

				if err != nil {
					return nil, err
				}
				r = r2
				v.Basic = value
				foundBasic = true
			case 2:
				r2, value, err := func(r []byte) ([]byte, KeyValue[uint32, bool], error) {
					var value KeyValue[uint32, bool]
					return value.Decode(r)
				}(r)

				if err != nil {
					return nil, err
				}
				r = r2
				v.WithGenerics = value
				foundWithGenerics = true
			case buf.EndMarker:
				break
		}
	}

	if !foundBasic {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: "basic"
		}
	}
	if !foundWithGenerics {
		return nil, buf.MissingFieldError{
			ID:    2
			Field: "with_generics"
		}
	}

	return r, nil
}

var _ buf.Size = (*Sample)(nil)

func (v *Sample) Size() int {
	size := 0
	size += buf.SizeField(1, func() int {
		return v.Basic.Size()
	})
	size += buf.SizeField(2, func() int {
		return v.WithGenerics.Size()
	})
	size += buf.SizeU32(buf.EndMarker)
	return size
}

type Test123Variant interface {
	 sealed()
}

type Test123 Test123Variant

type Test123_Value struct{}

func (v Test123_Value) sealed() {}

func NewTest123_Value() Test123_Value {
	return Test123_Value{}
}

var _ buf.Encode = (*Test123_Value)(nil)

func (v *Test123_Value) Encode(w []byte) []byte {
	return nil
}

var _ buf.Decode = (*Test123_Value)(nil)

func (v *Test123_Value) Decode(r []byte) ([]byte, error) {

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case buf.EndMarker:
				break
		}
	}


	return r, nil
}

var _ buf.Size = (*Test123_Value)(nil)

func (v *Test123_Value) Size() int {
	size := 0
	return size
}

type KeyValue[K any, V any] struct {
	Key K
	Value V
}

func NewKeyValue[K any, V any](
	key K,
	value V,
) KeyValue[K, V] {
	return KeyValue[K, V]{
		Key: key,
		Value: value,
	}
}

var _ buf.Encode = (*KeyValue[K, V])(nil)

func (v *KeyValue[K, V]) Encode(w []byte) []byte {
	w = buf.EncodeField(w, 1, func (w []byte) []byte {
		return v.Key.Encode(w)
	})
	w = buf.EncodeField(w, 2, func (w []byte) []byte {
		return v.Value.Encode(w)
	})
	w = buf.EncodeU32(w, buf.EndMarker)
	return w
}

var _ buf.Decode = (*KeyValue[K, V])(nil)

func (v *KeyValue[K, V]) Decode(r []byte) ([]byte, error) {
	foundKey := false
	foundValue := false

	for len(r) > 0 {
		r2, id, err := buf.DecodeID(r)
		if err != nil {
			return nil, err
		}
		r = r2

		switch id {
			case 1:
				r2, value, err := func(r []byte) ([]byte, K, error) {
					var value K
					return value.Decode(r)
				}(r)

				if err != nil {
					return nil, err
				}
				r = r2
				v.Key = value
				foundKey = true
			case 2:
				r2, value, err := func(r []byte) ([]byte, V, error) {
					var value V
					return value.Decode(r)
				}(r)

				if err != nil {
					return nil, err
				}
				r = r2
				v.Value = value
				foundValue = true
			case buf.EndMarker:
				break
		}
	}

	if !foundKey {
		return nil, buf.MissingFieldError{
			ID:    1
			Field: "key"
		}
	}
	if !foundValue {
		return nil, buf.MissingFieldError{
			ID:    2
			Field: "value"
		}
	}

	return r, nil
}

var _ buf.Size = (*KeyValue[K, V])(nil)

func (v *KeyValue[K, V]) Size() int {
	size := 0
	size += buf.SizeField(1, func() int {
		return v.Key.Size()
	})
	size += buf.SizeField(2, func() int {
		return v.Value.Size()
	})
	size += buf.SizeU32(buf.EndMarker)
	return size
}


